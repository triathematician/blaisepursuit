#summary This page describes the structure used to implement the pursuit/evasion simulations.
#labels Featured

= Iteration Structure Steps =
Generally speaking, pursuit/evasion algorithms between multiple players contain three steps: MTT (multiple target tracking), PEA (pursuer-evader assignment), and PP (path planning). These are all implemented in the steps of the main iteration of the pursuit simulation, the `Simulation.iterate(double time)` method.

 # *DISTANCE COMPUTATION*.
  * Recompute distances between all players (stored in *`DistanceTable`* class)
 # *CAPTURE CHECK*.
  * Check for any captures that may have occurred (as registered by any team's *`CaptureCondition`* distance threshold criterion). Depending on the `removal` setting, remove one or both of the pursuer and evader. The closest players are removed first.
   * _`CaptureCondition.check(DistanceTable dt, SimulationLog log, CaptureMap cap, double time)`_
  * Create a *`SignificantEvent`* and mark the capture point on the playing field.
   * _`SimulationLog.logCaptureEvent(Team owner, Agent first, Team target, Agent second, String string, DistanceTable dt, double time)`_
  * Store the capturing players and the capture time, for later use in computing metrics for the teams or partial teams.
   * _`CaptureMap.logCapture(Agent agent, Agent target, double time)`_
 # *VICTORY CHECK*.
  * Check for any "victory" that has occurred (as registered by a team's *`VictoryCondition`* class).
   * _`int VictoryCondition.check(DistanceTable dt, SimulationLog log, CaptureMap cap, double time)`_
  * The check may return "victory", "defeat", or "neither", obtained by comparing the valuation (from the parent class) to the given threshold.
   * _`Valuation.getValue(DistanceTable dt, CaptureMap cap)`_
  * If the check shows that the game should end, whether in victory or defeat, log an event to note this.
   * _`SimulationLog.logEvent(Team owner, Agent first, Team target, Agent second, String string, double time)`._
 # *MULTIPLE TARGET TRACKING (MTT)*.
  * Active players _sense_ their environment, by adding all agents in their sensory radius to their `Vector<Agent> pov`.
   * _`Team.gatherSensoryData(DistanceTable dt)`_
   * _`Agent.gatherSensoryData(DistanceTable dt)`_
  * Active players _communicate_ with teammates in their communications radius about what they see, by adding all sensed agents to their teammates `Vector<Agent> commpov`.
   * _`Team.communicateSensoryData(DistanceTable dt)`_
   * _`Agent.generateSensoryEvents(Team team,DistanceTable dist)`_
   * _`Agent.acceptSensoryEvent(Collection<Agent> agents)`_
  * Active players _fuse_ their own perceptions with those communicated by others to form a belief about what's really out there, currently by simply adding all agents in `commpov` to those in `pov`.
   * _`Team.fuseAgentPOV()`_
   * _`Agent.fusePOV()`_
 # TASKING / PURSUER-EVADER ASSIGNMENT (PEA)
  * "Control agent" generates tasks for all teammates
  * Individual agents generate tasks for all teammates
 # Task Fusion / Path Planning (PP)
  * Players turn the list of tasks they have into a DIRECTION in which they can travel
  * Use a *Behavior* to determine how to fuse the tasks together
  * Move all players